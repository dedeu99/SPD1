<!DOCTYPE html>
<html>
	<head>
		<title>SPD - POSIX Threads</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/cpp.min.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		

    
	</head>
		<body data-spy="scroll" data-target=".navbar" data-offset="50" style="margin-left:0px;>

			<div class="container">
				<div class="row">
					<div class="col-sm-3">

		<nav class="navbar bg-dark navbar-dark" style="margin-top:0px;padding-bottom:0px;height: 100%;position: fixed;">
			<ul class="navbar-nav">
				<li class="nav-item">
					<a class="nav-link" href="#requisitos">
						Pré-requisitos
					</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#thread">
						O que é uma thread?
					</a>	
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#aplicabilidade">
						Aplicabilidade
					</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#beneficios">
						Benefícios
					</a>
				</li>

				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Hello World
					</a>
					<div class="dropdown-menu">
						<a class="dropdown-item" href="#Hello world">Introdução</a>
						<a class="dropdown-item" href="#hello_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#hello_compilacao">Compilação</a>
						<a class="dropdown-item" href="#hello_programa">helloworld.c</a>
						<a class="dropdown-item" href="#hello_output">Output</a>
						<a class="dropdown-item" href="#hello_oqa">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Increment
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#Increment">Introdução</a>
						<a class="dropdown-item" href="#inc_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#inc_compilacao">Compilação</a>
						<a class="dropdown-item" href="#inc_programa">incremental_trap.c</a>
						<a class="dropdown-item" href="#inc_output">Output</a>
						<a class="dropdown-item" href="#inc_oqa">O que aconteceu?</a>
						<a class="dropdown-item" href="#inc_oqvu2">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#inc_compilacao2">Compilação</a>
						<a class="dropdown-item" href="#inc_programa2">incremental.c</a>
						<a class="dropdown-item" href="#inc_output2">Output</a>
						<a class="dropdown-item" href="#inc_oqa2">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Mutexes
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#Mutexes">Introdução</a>
						<a class="dropdown-item" href="#mut_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#mut_compilacao">Compilação</a>
						<a class="dropdown-item" href="#mut_programa">Mutexes.c</a>
						<a class="dropdown-item" href="#mut_output">Output</a>
						<a class="dropdown-item" href="#mut_oqa">O que aconteceu?</a>
						<a class="dropdown-item" href="#mut_oqvu2">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#mut_compilacao2">Compilação</a>
						<a class="dropdown-item" href="#mut_programa2">Deadlock.c</a>
						<a class="dropdown-item" href="#mut_output2">Output</a>
						<a class="dropdown-item" href="#mut_oqa2">O que aconteceu?</a>
						<a class="dropdown-item" href="#mut_oqvu3">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#mut_compilacao3">Compilação</a>
						<a class="dropdown-item" href="#mut_programa3">no_deadlock.c</a>
						<a class="dropdown-item" href="#mut_output3">Output</a>
						<a class="dropdown-item" href="#mut_oqa3">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Condition Variables
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#ConditionVariables">Introdução</a>
						<a class="dropdown-item" href="#Cond_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#Cond_compilacao">Compilação</a>
						<a class="dropdown-item" href="#Cond_programa">Conditionals.c</a>
						<a class="dropdown-item" href="#Cond_output">Output</a>
						<a class="dropdown-item" href="#Cond_oqa">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Informação Adicional
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#pthread1">Pthreads</a>
					</div>
				</li>
			</ul>
		</nav>

			
					</div>

					<div class="col-sm-9">
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="requisitos">
							<h1>Requisitos</h1>
							<p>Antes de iniciarmos o estudo da biblioteca pthreads existem alguns conceitos que são necessários, nomeadamente:</p>
							<ul>
								<li>Programação na linguagem C :<a href="url">https://www.tutorialspoint.com/cprogramming/ </a> 
									<ul>
										<li>Compilação:<a href="url"> https://www.tutorialspoint.com/cprogramming/c_program_structure.htm</a></li>
										<li></li>
										<li>Diferença entre stack e heap: <a href="url">https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html</a></li>
									</ul>

								</li>
								<li>MAKEFILE:<a href="url"> https://www.tutorialspoint.com/makefile/index.htm </a></li>
								<li>Processos UNIX : </li>
							</ul>
						</div>
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="thread">
							<h1>O que é uma thread?</h1>
							<p>Uma thread pode ser compreendida como um fio de execução independente ainda que contido no âmbito de um processo, ou seja, uma thread possui acesso a recursos do processo do qual origina porém é gerido independentemente pelo sistema operativo.</p>
							<p>Uma boa metáfora para compreendermos como funcionam os programas tradicionais e os programas que utilizam multi threading seria imaginar o funcionamento de um restaurante. Com apenas um trabalhador, este teria de atender os clientes, levantar os pedidos, cozinhar, servir à mesa e fazer caixa. Imaginando agora que temos cinco trabalhadores nesse mesmo restaurante, cada um poderia estar designado a uma dessas tarefas e estas seriam executadas simultaneamente com os restantes, melhorando assim o funcionamento do restaurante.</p>
						</div>
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="aplicabilidade">
							<h1>Aplicabilidade</h1>
							<p>As Pthreads permitem ao programador criar threads no seu programa que executam independentemente do código principal, ou seja, permitem que o computador execute duas tarefas ou mais tarefas em simultâneo, reduzindo assim o tempo necessário para a execução do programa. Numa arquitetura em série o tempo necessário para a execução de programas é muito maior pois não existem threads para executar cada uma das tarefas que o programa pede singularmente.</p>
							<p>Existem três padrões de desenho de threads comuns:</p>
							<ol>
								<li>Thread Pool (Manager/worker) - Consiste numa thread que delega outras threads executar certas tarefas. A thread que delega tarefas tem o nome de Manager e existe uma worker thread pool onde se encontram todas as threads antes de serem delegadas para executar as várias tarefa.</li>
								<li>Peer (Workcrew) – Este modelo é parecido ao anterior com exceção de que assim que todas as threads que se encontram na work pool forem designadas para executar as suas tarefas, a thread Manager passa a ser mais uma thread dentro da work pool que executa também as tarefas.</li>
								<li>Pipeline – Cada thread trabalha com informação processada pela thread anterior e entrega à próxima thread. È necessário ter cuidado na distribuição de trabalho entre as threads para não acontecer bloqueios. Um exemplo prático é as construções dos carros nas fábricas em que cada máquina monta a peça que é suposto montar e passa o carro para a máquina seguinte para esta montar outra peça.</li>
							</ol>
							<p>O uso de Pthreads é muito útil pois quando comparado com o custo de criação de processos, as Threads podem ser criadas com muito menos recursos do sistema operativo. Em termos de comunicação e intercambio de informação as Pthreads também tem uma performance muito boa pois as Threads possuem o mesmo espaço de endereçamento dentro de um processo. Logo não existe a necessidade de transferir informação.</p>
							<p>As threads são apropriadas quando o programador se depara com:</p>
							<ul>
								<li>Operações assincronas como operações I/O potencialmente longas</li>
								<li>Operações que independentes que podem ser paralelizadas</li>
								<li>Operações que são executadas continuamente em background</li>
							</ul>
						</div>

						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="beneficios">
							<h1>Benefícios</h1>
							<p>Quando diversas threads são executadas numa arquitectura multicore, numa aplicação com um desenho eficiente (com uma divisão de tarefas no código e sincronismos bem planeados), é possível obter melhorias de performance.</p>
							<p>Comparativamente ao uso de vários processos, o uso de várias threads num processo reduz o tempo necessário para a troca de informação, visto que as threads usam os recursos de um mesmo processo, e evita a troca entre processos o que é uma operação que requere bastantes recursos da CPU</p>




						
						<p>É também importante salientar que:</p>
						<ul>
							<li>demasiadas threads num sistema poderá diminuir o desempenho da aplicação visto que o sistema operativo poderá gastar mais ciclos de CPU a processar a troca entre threads do que a executar as threads em si</li>
							<li>demasiado sincronismo entre threads poderá provocar uma diminuição da performance da aplicação visto que operações de sincronização são demoradas</li>
							<li>a criação de threads poderá diminuir a performance da cache de um processo</li>
						</ul>

						</div>
						
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Hello world">
			<h1>Hello world</h1>
			<p>Para iniciarmos o estudo das pthreads, como habitual, iremos contruir um exemplo helloworld. O executável espera um parâmetro na linha de comandos que indica o número de threads a executar e, cada thread irá colocar no stdout uma pequena mensagem com o seu índice na pool das threads.</p>

			<h4 id="hello_oqvu">O que vamos utilizar?</h4>
			<pre><code class="c">pthread_t</code></pre>
			<p>Tipo usado para identificar uma thread - :<a href="url"> http://pubs.opengroup.org/onlinepubs/7908799/xsh/systypes.h.html </a></p>
			<pre><code class="c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);</code></pre> 
            <p>Cria uma nova thread que tem como ponto de entrada o método passado no terceiro argumento e, esse método, tem como parâmetro o quarto argumento da função pthread_create(). O primeiro parâmetro deverá ser um pointer para o handle da thread. Retorna 0 caso a thread tenha sido criada com sucesso ou um código de erro caso contrário.<a href="url"> http://man7.org/linux/man-pages/man3/pthread_create.3.html</a></p>
			<pre><code class="c">void pthread_exit(void *retval);</code></pre> 
			<p>Termina a thread corrente e o seu valor de retorno é usado aquando a invocação da função pthread_join(). :<a href="url"> http://man7.org/linux/man-pages/man3/pthread_exit.3.html </a></p>

			<h4 id="hello_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make hello</kbd>
			<h4 id="hello_programa">helloworld.c</h4>
			<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>



void* hello(void * thread) {
  printf("HELLO WORLD BY THREAD %ld\n",(long)thread);

  pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  int nthreads=0;
  if(argc==2)
    nthreads=atoi(argv[1]);
  else{
    printf(
    "USAGE: helloworld &lt;threads>\n"
    "\n"
    "ARGUMENTS\n"
    "  &lt;threads>  Number of threads to create that increment a value\n"
    "\n"
    "Creates &lt;threads> threads and makes them print their a message with their index in the pool to stdout.\n");
    exit(0);
  } 
  pthread_t threads[nthreads];
  int i=0;

  for(i=0;i&lt; nthreads;++i){

    int res = pthread_create(&threads[i], NULL, hello, (void*)i);
    if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }    
  }
  
  
/*calling exit(0) will terminate the whole process and, consequently, the threads.
Use pthread_exit to make sure the process only gets terminated upon all threads completion.*/
    pthread_exit(NULL); 
}
			</code></pre>
			<h4 id="hello_output">Output</h4>
			<kbd>HELLO WORLD BY THREAD 0<br>
HELLO WORLD BY THREAD 7<br>
HELLO WORLD BY THREAD 2<br>
HELLO WORLD BY THREAD 3<br>
HELLO WORLD BY THREAD 4<br>
HELLO WORLD BY THREAD 5<br>
HELLO WORLD BY THREAD 6<br>
HELLO WORLD BY THREAD 1<br>
HELLO WORLD BY THREAD 8<br>
HELLO WORLD BY THREAD 9</kbd>
			<h4 id="hello_oqa">O que aconteceu?</h4>
			
			<p>Foram criadas &lt;threads> threads, conforme passado como argumento para a função e cada uma colocou no stdout o seu indice na pool.</p>
			<p>É de notar que, como cada thread tem uma linha de execução independente, poderão não executar pela ordem que foram criadas.</p>
		</div>
















		<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Increment">


			<h1>Increment</h1>
			<p>Queremos agora que as thread efetuem algo mais que colocar strings no stdout. Para o propósito desta página iremos atualizar o código anterior, criando agora uma variável global que será incrementada apenas uma vez pelas várias threads e comentar os resultados obtidos.</p>

			<h4 id="inc_oqvu">O que vamos utilizar?</h4>
			
			<p>Nada de novo, vamos apenas atualizar o código existente.</p>

			<h4 id="inc_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make inc_trap</kbd>
			<h4 id="inc_programa">incremental_trap.c</h4>
			<pre><code class="c">

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>


int i=0;

void* inc(void * threadid) {
		i++;
	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  
	int nthreads=0;
	if(argc==2)
		nthreads=atoi(argv[1]);
	else{
		printf(
		"USAGE: inc_trap &lt;threads>\n"
		"\n"
		"ARGUMENTS\n"
		"  &lt;threads>  Number of threads to create that increment a value\n"
		"\n"
		"Since every thread increment the same variable only once, it's expected that the final result will be == to <threads>\n"
		"Try running '$int_trap 1' to confirm such behaviour\n"
		"Afterwards try running '$int_trap 999'\n");
	}	
	
	pthread_t threads[nthreads];
	

	for(int t=0;t&lt; nthreads;++t){

    	int res = pthread_create(&threads[t], NULL, inc, NULL);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}	

  	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
	pthread_exit(NULL);
}
				</code></pre>
			<h4 id="inc_output">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:(&lt;threads>-1)</kbd>
			<h4 id="inc_oqa">O que aconteceu?</h4>
			
			<p>Enquanto o main está no ciclo for e, como a instrução de incrementar é simples, as threads executam imediatamente e incrementam o valor corretamente porém, main sendo também ela uma thread tem uma linha de execução diferente e coloca no stdout o resultado antes da última thread o incrementar (pode até acontecer a várias threads).</p>
			<p>Uma solução seria apenas fazer printf após o pthread_exit pois este, no main, garante que as threads filhas terminem e funciona como um ponto de execução porém tal é impossível visto que o pthread_exit funciona como um return e termina a thread atual...</p>
			<p>Iremos de seguida ver a solução para este problema</p>

			<h4 id="inc_oqvu2">O que vamos utilizar?</h4>
			<pre><code class="c">int pthread_join(pthread_t thread, void **retval);</code></pre> 
			<p>Esta função aguarda que a thread passada como parâmetro termine antes de prosseguir.Coloca em retval o valor passado na função pthread_exit da thread terminada.http://man7.org/linux/man-pages/man3/pthread_join.3.html</p>
			<h4 id="inc_compilacao2">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make inc</kbd>
			<h4 id="inc_programa2">incremental.c</h4>
			.</br>
			.</br>
			.</br>
			<pre><code class="c">
int main(){

.
.
.
for(int t=0;t< nthreads;++t)
	<b>pthread_join(threads[t], NULL);</b>

	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
	pthread_exit(NULL);
}</code></pre>
<h4 id="inc_output2">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:&lt;threads></kbd>
			<h4 id="inc_oqa2">O que aconteceu?</h4>
			<p>Ao invocarmos pthread_join sobre todas as threads da pool garantimos que estas terminam antes da função main continuar a sua execução imprimindo assim o valor correcto da variável result.</p>
			<p>Porém, se executarmos o programa vezes suficientes e com threads suficientes podemos ter um output inesperado...</p>

			 <kbd>$./inc 999<br>
Number of threads:999   incremental result:999<br>
$./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:998        &lt;-----------<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999</kbd>
			s
</div>




<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Mutexes">
	<h1>Mutexes</h1>
	<p>Para resolver problemas de concorrência a API pthreads proporciona-nos mutexes que fornecem acesso atómico às pthreads, ou seja, garantem que, o acesso a recursos partilhados sejam efetuados exclusivamente pela thread que detêm o acesso aos mesmos.</p>
			<h4 id="mut_oqvu3">O que vamos utilizar?</h4>
			<pre><code class="c">pthread_mutex_t</code></pre> 
			<p>Tipo usado para identificar um mutex.<a href="url"> http://pubs.opengroup.org/onlinepubs/7908799/xsh/systypes.h.html</a></p>
			<pre><code class="c">int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></pre> 
			<p>Estas funções criam/destroem um mutex.</p>
			<pre><code class="c">int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></pre> 
			<p>Estas funções permitem que uma thread obtenha/disponibilize acesso a um mutex,respectivamente.No caso de unlock o desbloqueio é imediato porém, após invocar o lock, a thread invocadora aguarda até que o acesso esteja disponível e só ent
			ão prossegue com as restantes instruções.<a href="url"> http://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html<a></p>




			<h4 id="mut_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make mutexes</kbd>
			<h4 id="mut_programa">mutexes.c</h4>
			<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>


int i=0;
pthread_mutex_t i_mutex;

void* inc(void * threadid) {

	pthread_mutex_lock(&i_mutex);
	i++;
	pthread_mutex_unlock(&i_mutex);

	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  
	int nthreads=0;
	if(argc==2)
		nthreads=atoi(argv[1]);
	else{
		printf(
		"USAGE: mutexes &lt;threads>\n"
		"\n"
		"ARGUMENTS\n"
		"  &lt;threads>  Number of threads to create that increment a value\n"
		"\n"
		"Since every thread increment the same variable only once, it's expected that the final result will be == to <threads>\n"
		"Try running '$int_trap 10' to confirm such behaviour\n"
		"Afterwards try running '$int_trap 999' several times and see what happens\n"
		"To ease the repetion of commands try the following:\n"
		"'$int_trap 999'\n"
		"'$!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;'\n");
	}	
	
	pthread_t threads[nthreads];
	
	pthread_mutex_init(&i_mutex,NULL);

	for(int t=0;t&lt; nthreads;++t){

    	int res = pthread_create(&threads[t], NULL, inc, NULL);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}	
	
	for(int t=0;t&lt; nthreads;++t)
  		pthread_join(threads[t], NULL);
  	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
  	pthread_mutex_destroy(&i_mutex);
	pthread_exit(NULL);
}
</code></pre> 

<h4 id="mut_output">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:&lt;threads></kbd>
			<h4 id="inc_oqa">O que aconteceu?</h4>
			<p>Após incluirmos mutexes no código da aplicação. cada bloco lock-unlock apenas executa na sua totalidade pela thread detentora do lock, eliminando assim acessos concorrentes à variável incrementada.</p>

			<p>Eis um diagrama a ilustrar a situação:</p>
			<img src="diagrama2.png">

<h4 id="mut_oqvu2"> E se for necessário aceder a vários recursos simultaneamente?</h4>
	<p> No exemplo seguinte queremos duas threads em que uma incrementa uma variável uma vez e a outra adiciona 2, no entanto, queremos também saber quantas vezes uma thread executa em relação a outra, ou seja, descobrir qual thread executa mais vezes e quantas vezes.
	Para isso uma thread incrementa uma variável enquanto a outra thread decrementa essa mesma variável. No final o valor dessa variável mostrará a diferença no número de execuções.<p>
		
<h4 id="mut_compilacao2">Compilação</h4>
		<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
		<kbd>$make deadlock</kbd>
		<h4 id="mut_programa2">deadlock.c</h4>	
		<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>

int max=0;
int i=0;
int j=0;
pthread_mutex_t i_mutex;
pthread_mutex_t j_mutex;

void* inc(void * threadid) {
	while(i&lt;max){
		pthread_mutex_lock(&i_mutex);
		pthread_mutex_lock(&j_mutex);
		i++;
		j--;
		pthread_mutex_unlock(&j_mutex);
		pthread_mutex_unlock(&i_mutex);
	}
	pthread_exit(NULL);
}
void* inc2(void * threadid) {
	while(i&lt;max-1){
		pthread_mutex_lock(&j_mutex);
		pthread_mutex_lock(&i_mutex);
		i+=2;
		j++;
		pthread_mutex_unlock(&i_mutex);
		pthread_mutex_unlock(&j_mutex);
	}
	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  	
	
	if(argc==2)
		max=atoi(argv[1]);
	else{
		printf("USAGE: deadlock &lt;max_number>\n"
		"\n"
		"ARGUMENTS\n"
		"   &lt;max_number>  maximum number two threads can count up to\n"
		"\n"
		"One thread increments a counter be one and one increments a counter by two up to <max_number>.\n"
		"We count the difference between the number of times thread1 counted and thread2 executed.\n"
		"If result ==0, both threads executed the same number of times.\n"
		"If result &lt; 0, thread1 executed abs(result) more times .\n"
		"If result > 0, thread2 executed abs(result) more times .\n"
		"Afterwards try running '$deadlock <n>' and see what happens for n=10 and n=999\n");
		exit(0);
	}	
	int nthreads=2;
	pthread_t threads[nthreads];
	
	pthread_mutex_init(&i_mutex,NULL);
	pthread_mutex_init(&j_mutex,NULL);


	int res = pthread_create(&threads[0], NULL, inc, NULL);
	if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }  
    
    res = pthread_create(&threads[1], NULL, inc2, NULL);
	if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }
    for(int t=0; t&lt; nthreads;++t)
	pthread_join(threads[t], NULL);
	printf("Number of threads:%d   incremental result:%d    diff in number of executions:%d\n",nthreads,i,j);
  	pthread_mutex_destroy(&i_mutex);
	pthread_exit(NULL);
    }

</code></pre> 

	<h4 id="mut_output2">Output</h4>
	
	<h4 id="inc_oqa2">O que aconteceu?</h4>
	<p> Ambas as thread tentam ganhar o acesso aos mutexes em sequências diferentes, ou seja, quando ambas as threads possuem o acesso a um mutex, cada um requer o acesso ao outro mutex e ficam
	à espera que o recurso fique disponível, porém, como ambas estão à espera, nunca libertam o seu recurso o que causa uma situação de deadlock onde nenhuma das threads irá executar. </p>
	
	<h4 id="inc_oqvu3">O que vamos utilizar?</h4>
	<pre><code class="c"> int pthread_mutex_trylock(pthread_mutex_t *mutex); </code></pre>
	<p>O pthread_mutex_trylock tenta dar lock a um mutex. Se o mutex já estiver locked, vai ser apresentado um erro “busy” . Caso o mutex não esteja locked a thread dá lock ao mutex.</p>
	<h4 id="mut_compilacao3">Compilação</h4>
	<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
	<kbd>$make nodeadlock</kbd>
	<h4 id="mut_programa3">no_deadlock.c</h4>	
	<pre><code class="c">
	
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>

int max=0;
int i=0;
int j=0;
pthread_mutex_t i_mutex;
pthread_mutex_t j_mutex;

void* inc(void * threadid) {
	while(i&lt; max)
	{
		pthread_mutex_lock(&i_mutex);
		if(!pthread_mutex_trylock(&j_mutex)&&i&lt;max)
		{
			i++;
			j--;
			pthread_mutex_unlock(&j_mutex);
		}
		pthread_mutex_unlock(&i_mutex);
	}
	pthread_exit(NULL);
}
void* inc2(void * threadid) {
	while(i&lt; max-1){
		pthread_mutex_lock(&j_mutex);
		if(!pthread_mutex_trylock(&i_mutex)&&i&lt;max-1)
		{
			i+=2;
			j++;
			pthread_mutex_unlock(&i_mutex);
		}
		pthread_mutex_unlock(&j_mutex);
	}
	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  	
	
	if(argc==2)
		max=atoi(argv[1]);
	else{
		printf("USAGE: no_deadlock &lt;max_number> \n"
		"\n"
		"ARGUMENTS\n"
		"   &lt;max_number>  maximum number two threads can count up to\n"
		"\n"
		"One thread increments a counter be one and one increments a counter by two up to &lt;max_number>.\n"
		"We count the difference between the number of times thread1 counted and thread2 executed.\n"
		"If result ==0, both threads executed the same number of times.\n"
		"If result &lt; 0, thread1 executed abs(result) more times .\n"
		"If result > 0, thread2 executed abs(result) more times .\n"
		"Afterwards try running '$no_deadlock <n>' and see what happens for n=9999 several times\n"
		"To ease the repetion of commands try the following:\n"
		"'$no_deadlock 9999'\n"
		"'$!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;'\n");
		exit(0);
	}	
	int nthreads=2;
	pthread_t threads[nthreads];
	
	pthread_mutex_init(&i_mutex,NULL);
	pthread_mutex_init(&j_mutex,NULL);


	int res = pthread_create(&threads[0], NULL, inc, NULL);
	if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }  
    
    res = pthread_create(&threads[1], NULL, inc2, NULL);
	if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }  

	for(int t=0;t&lt; nthreads;++t)
	pthread_join(threads[t], NULL);
  	printf("Number of threads:%d   incremental result:%d    diff in number of executions:%d\n",nthreads,i,j);
  	pthread_mutex_destroy(&i_mutex);
	pthread_exit(NULL);
}
</code></pre>

<h4 id="mut_output3">Output</h4>

<h4 id="mut_oqa3">O que aconteceu?</h4>
<p>Com o uso de pthread_mutex_trylock(), em caso de o mutex a que a thread pretende ter acesso esteja locked por outra thread, o programa prossegue e a thread irá dar unlock ao mutex que tinha dado lock. Isto faz com que a outra 
thread que tem o mutex locked consiga avançar pois o recurso ficou disponível e vai ser possível executar. Após esta thread ter concluído a execução, irá libertar os dois mutex e assim a primeira thread pode dar lock aos dois mutexes que pretende e executar livremente.</p>


		
	<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Informação Adicional">
	<h1>Informação Adicional</h1>
	<h4 id="pthread1">Pthreads Adicionais</h4>
	<pre><code class="c"> int pthread_cancel(pthread_t thread); </code></pre>
	<p> A função pthread_cancel() cancela a execução de uma thread. A thread a ser cancelada controla quando o cancelamento terá efeito dependendo do estado e tipo de cancelabilidade da mesma.</p>
	<pre><code class="c"> int pthread_detach(pthread_t thread); </code></pre>
	<p> A função pthread_detach() marca uma thread para esta libertar os seus recursos de volta ao sistema, após a sua execução, sem a necessidade de outra thread fazer um join com esta. Esta função, no entanto, não irá causar o término da thread casoesta não tenha anda terminado a sua execução. </p>
	</div>
	<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="ConditionVariables">
<h1>Condition Variables</h1>
<p>As variáveis de condição fornecem-nos outra maneira de sincronizar threads. Enquanto que as mutexes implementam a sincronização controlando o acesso das threads à data, as variáveis de condição
permitem às threads sincronizarem pelo valor atual de data. As variáveis de condição são sempre utilizadas em junção com os mutex locks.</p>
<h4 id="Cond_oqvu">O que vamos utilizar?</h4>
<pre><code class="c">
pthread_cond_t cond
</code></pre>
<p>Tipo usado para identificar uma variável de condição</p>

<pre><code class="c">
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr);
</code></pre>
<p>Estas funções criam/destroem uma variável de condição.</p>

<pre><code class="c">
int pthread_cond_signal(pthread_cond_t *cond); 
</code></pre>
<p> Esta função desbloqueia pelo menos uma thread que esteja bloqueado por uma variável de condição. https://linux.die.net/man/3/pthread_cond_signal</p>
<pre><code class="c">
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex); 
</code></pre>
<p>Esta função bloqueia uma thread através de uma variável de condição. https://linux.die.net/man/3/pthread_cond_wait</p>

<h4 id="Cond_compilacao">Compilação</h4>
<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
		<kbd>$make conds</kbd>
<h4 id="Cond_programa">conditionals.c</h4>
<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;thread.h>

//FILO AKA STACK
typedef struct buffer{
	unsigned int maxSize;
	unsigned int numElems;
	int* values;

}Buffer;

Buffer* b;
pthread_mutex_t Buffermutex;
pthread_cond_t consumir, encher;



Buffer* makeBuffer(int maxSize){
	Buffer* b=(Buffer*)malloc(sizeof(Buffer));
	b->values=(int*)malloc(sizeof(int)*maxSize);	
	b->maxSize=maxSize;
	b->numElems=0;
	return b;
}
void freeBuffer(Buffer* b){
	free(b->values);
	free(b);
}
int push(Buffer* b,int value){
	if(b->numElems>=b->maxSize)
		return 0;

	b->values[b->numElems++]=value;
	return 1;
}
int pop(Buffer* b){
	if(b->numElems==0)
		return 0;
	return b->values[--	b->numElems];
}
void printBuffer(Buffer* b){
	if(b->numElems==0){
		printf("EMPTY\n");
		return;
	}

	for(int i=0;i&lt;b->numElems;++i)
		printf("%d,",b->values[i]);
	printf("\n");
}
int isFull(Buffer* b){
	return b->numElems==b->maxSize;
}
int isEmpty(Buffer* b){
	return b->numElems==0;
}

void make(void *arg){
	push(b,(int)arg);
	//printf("put %d\n",(int)arg);
}

void spend(void *arg){
	pop(b);
}

void* produce(void *arg){
	pthread_mutex_lock(&Buffermutex);
	while (isFull(b)){
		
		pthread_cond_wait(&encher, &Buffermutex);
	}
	make(arg);
	pthread_cond_signal(&consumir);
	pthread_mutex_unlock(&Buffermutex);
	pthread_exit(NULL);
}
void *consume(void *arg) {
	pthread_mutex_lock(&Buffermutex);
	while (isEmpty(b)){
		 
		pthread_cond_wait(&consumir, &Buffermutex);
	}
	spend(arg);
	pthread_cond_signal(&encher);
	pthread_mutex_unlock(&Buffermutex);
	pthread_exit(NULL);
}


int main(int argc,  char** argv) {
  	int max=0,nconsumidores=0,nprodutores=0;
	
	if(argc==4){
		max=atoi(argv[1]);
		nconsumidores=atoi(argv[2]);
		nprodutores=atoi(argv[3]);

	}else{
		printf("USAGE: conditionals &lt;max> &lt;nproducers> &lt;nconsumers>\n"
		"\n"
		"ARGUMENTS\n"
		"   &lt;max_number>  maximum number two threads can count up to\n"
		"\n"
		"One thread increments a counter be one and one increments a counter by two up to &lt;max_number>.\n"
		"We count the difference between the number of times thread1 counted and thread2 executed.\n"
		"If result ==0, both threads executed the same number of times.\n"
		"If result &lt; 0, thread1 executed abs(result) more times .\n"
		"If result > 0, thread2 executed abs(result) more times .\n"
		"Afterwards try running '$no_deadlock &lt;n>' and see what happens for n=9999 several times\n"
		"To ease the repetion of commands try the following:\n"
		"'$no_deadlock 9999'\n"
		"'$!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;'\n");
		exit(0);
	}

	pthread_t consumidores[nconsumidores],produtores[nprodutores];
	b=makeBuffer(max);

	pthread_mutex_init(&Buffermutex, NULL);
   	pthread_cond_init (&consumir, NULL);
   	pthread_cond_init (&encher, NULL);


   	
	
	for(int t=0;t&lt;nconsumidores;t++){

    	int res = pthread_create(&consumidores[t], NULL, consume, t);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}
	for(int t=0;t&lt;nprodutores;t++){

    	int res = pthread_create(&produtores[t], NULL, produce, t);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}	
	

	for (int i=0; i&lt;nprodutores; i++) 
		pthread_join(produtores[i], NULL);
	for (int i=0; i&lt;nconsumidores; i++) 
		pthread_join(consumidores[i], NULL);
	
   for(int t=0;t&lt;15;t++)
		printBuffer(b);
 	pthread_mutex_destroy(&Buffermutex);
	pthread_cond_destroy(&consumir);
	pthread_cond_destroy(&encher);
	free(b);
	pthread_exit(NULL);

}
</code></pre>

<h4 id="Cond_output">Output?</h4>
<h4 id="Cond_oqa3">O que aconteceu?</h4>
		</div>
					</div>




				</div>
&lt;



FALTA FALAR DE:
-		thread_cancel
-		thread_detach
-		tipos de atributos para os mutexes



pthread_exit

-When a thread terminates, process-shared resources (e.g., mutexes,
       condition variables, semaphores, and file descriptors) are not
       released, and functions registered using atexit(3) are not called.

pthread_cancel

-A função pthread_cancel() cancela a execução de uma thread. A thread a ser 
cancelada controla quando o cancelamento terá efeito dependendo do estado e 
tipo de cancelabilidade da mesma.

pthread_detach

-A função pthread_detach() marca uma thread para esta libertar os seus recursos 
de volta ao sistema, após a sua execução, sem a necessidade de outra thread fazer 
um join com esta. Esta função, no entanto, não irá causar o término da thread caso
 esta não tenha anda terminado a sua execução.


INFO ADICIONAL:
	This independent flow of control is accomplished because a thread maintains its own:
Stack pointer
Registers
Scheduling properties (such as policy or priority)
Set of pending and blocked signals
Thread specific data.

















leitura adicional:
http://www.drdobbs.com/parallel/the-pillars-of-concurrency/200001985



		<br>
		<footer>
			<div class="row justify-content-around">     
				<p>a62362 - a49371 - aXXXXX - aXXXXX - aXXXXX</p>
			</div>
		</footer>
</div>
  
	</body>
</html>
