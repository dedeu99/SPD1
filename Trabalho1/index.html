<!DOCTYPE html>
<html>
	<head>
		<title>SPD - POSIX Threads</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/cpp.min.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
		

    
	</head>
		<body data-spy="scroll" data-target=".navbar" data-offset="50" style="margin-left:0px;>

			<div class="container">
				<div class="row">
					<div class="col-sm-3">

		<nav class="navbar bg-dark navbar-dark" style="margin-top:0px;padding-bottom:0px;height: 100%;position: fixed;">
			<ul class="navbar-nav">
				<li class="nav-item">
					<a class="nav-link" href="#requisitos">
						Pré-requisitos
					</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#thread">
						O que é uma thread?
					</a>	
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#aplicabilidade">
						Aplicabilidade
					</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#beneficios">
						Benefícios
					</a>
				</li>

				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Hello World
					</a>
					<div class="dropdown-menu">
						<a class="dropdown-item" href="#Hello world">Introdução</a>
						<a class="dropdown-item" href="#hello_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#hello_compilacao">Compilação</a>
						<a class="dropdown-item" href="#hello_programa">helloworld.c</a>
						<a class="dropdown-item" href="#hello_output">Output</a>
						<a class="dropdown-item" href="#hello_oqa">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Increment
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#Increment">Introdução</a>
						<a class="dropdown-item" href="#inc_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#inc_compilacao">Compilação</a>
						<a class="dropdown-item" href="#inc_programa">incremental_trap.c</a>
						<a class="dropdown-item" href="#inc_output">Output</a>
						<a class="dropdown-item" href="#inc_oqa">O que aconteceu?</a>
						<a class="dropdown-item" href="#inc_oqvu2">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#inc_compilacao2">Compilação</a>
						<a class="dropdown-item" href="#inc_programa2">incremental.c</a>
						<a class="dropdown-item" href="#inc_output2">Output</a>
						<a class="dropdown-item" href="#inc_oqa2">O que aconteceu?</a>
					</div>
				</li>
				<li class="nav-item dropdown">
					<a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
						Mutexes
					</a>
					<div class="dropdown-menu dropdown-menu-right">
						<a class="dropdown-item" href="#Mutexes">Introdução</a>
						<a class="dropdown-item" href="#mut_oqvu">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#mut_compilacao">Compilação</a>
						<a class="dropdown-item" href="#mut_programa">incremental_trap.c</a>
						<a class="dropdown-item" href="#mut_output">Output</a>
						<a class="dropdown-item" href="#mut_oqa">O que aconteceu?</a>
						<a class="dropdown-item" href="#mut_oqvu2">O que vamos utilizar?</a>
						<a class="dropdown-item" href="#mut_compilacao2">Compilação</a>
						<a class="dropdown-item" href="#mut_programa2">incremental.c</a>
						<a class="dropdown-item" href="#mut_output2">Output</a>
						<a class="dropdown-item" href="#mut_oqa2">O que aconteceu?</a>
					</div>
				</li>
			</ul>
		</nav>

			
					</div>

					<div class="col-sm-9">
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="requisitos">
							<h1>Requisitos</h1>
							<p>Antes de iniciarmos o estudo da biblioteca pthreads existem alguns conceitos que são necessários, nomeadamente:</p>
							<ul>
								<li>Programação na linguagem C : https://www.tutorialspoint.com/cprogramming/ 
									<ul>
										<li>Compilação: https://www.tutorialspoint.com/cprogramming/c_program_structure.htm</li>
										<li></li>
										<li>Diferença entre stack e heap: https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html</li>
									</ul>

								</li>
								<li>MAKEFILE: https://www.tutorialspoint.com/makefile/index.htm</li>
								<li>Processos UNIX : </li>
							</ul>
						</div>
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="thread">
							<h1>O que é uma thread?</h1>
							<p>Uma thread pode ser compreendida como um fio de execução independente ainda que contido no âmbito de um processo, ou seja, uma thread possui acesso a recursos do processo do qual origina porém é gerido independentemente pelo sistema operativo.</p>
							<p>Uma boa metáfora para compreendermos como funcionam os programas tradicionais e os programas que utilizam multi threading seria imaginar o funcionamento de um restaurante. Com apenas um trabalhador, este teria de atender os clientes, levantar os pedidos, cozinhar, servir à mesa e fazer caixa. Imaginando agora que temos cinco trabalhadores nesse mesmo restaurante, cada um poderia estar designado a uma dessas tarefas e estas seriam executadas simultaneamente com os restantes, melhorando assim o funcionamento do restaurante.</p>
						</div>
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="aplicabilidade">
							<h1>Aplicabilidade</h1>
							<p>As Pthreads permitem ao programador criar threads no seu programa que executam independentemente do código principal, ou seja, permitem que o computador execute duas tarefas ou mais tarefas em simultâneo, reduzindo assim o tempo necessário para a execução do programa. Numa arquitetura em série o tempo necessário para a execução de programas é muito maior pois não existem threads para executar cada uma das tarefas que o programa pede singularmente.</p>
							<p>Existem três padrões de desenho de threads comuns:</p>
							<ol>
								<li>Thread Pool (Manager/worker) - Consiste numa thread que delega outras threads executar certas tarefas. A thread que delega tarefas tem o nome de Manager e existe uma worker thread pool onde se encontram todas as threads antes de serem delegadas para executar as várias tarefa.</li>
								<li>Peer (Workcrew) – Este modelo é parecido ao anterior com exceção de que assim que todas as threads que se encontram na work pool forem designadas para executar as suas tarefas, a thread Manager passa a ser mais uma thread dentro da work pool que executa também as tarefas.</li>
								<li>Pipeline – Cada thread trabalha com informação processada pela thread anterior e entrega à próxima thread. È necessário ter cuidado na distribuição de trabalho entre as threads para não acontecer bloqueios. Um exemplo prático é as construções dos carros nas fábricas em que cada máquina monta a peça que é suposto montar e passa o carro para a máquina seguinte para esta montar outra peça.</li>
							</ol>
							<p>O uso de Pthreads é muito útil pois quando comparado com o custo de criação de processos, as Threads podem ser criadas com muito menos recursos do sistema operativo. Em termos de comunicação e intercambio de informação as Pthreads também tem uma performance muito boa pois as Threads possuem o mesmo espaço de endereçamento dentro de um processo. Logo não existe a necessidade de transferir informação.</p>
							<p>As threads são apropriadas quando o programador se depara com:</p>
							<ul>
								<li>Operações assincronas como operações I/O potencialmente longas</li>
								<li>Operações que independentes que podem ser paralelizadas</li>
								<li>Operações que são executadas continuamente em background</li>
							</ul>
						</div>

						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="beneficios">
							<h1>Benefícios</h1>
							<p>Quando diversas threads são executadas numa arquitectura multicore, numa aplicação com um desenho eficiente (com uma divisão de tarefas no código e sincronismos bem planeados), é possível obter melhorias de performance.</p>
							<p>Comparativamente ao uso de vários processos, o uso de várias threads num processo reduz o tempo necessário para a troca de informação, visto que as threads usam os recursos de um mesmo processo, e evita a troca entre processos o que é uma operação que requere bastantes recursos da CPU</p>




						
						<p>É também importante salientar que:</p>
						<ul>
							<li>demasiadas threads num sistema poderá diminuir o desempenho da aplicação visto que o sistema operativo poderá gastar mais ciclos de CPU a processar a troca entre threads do que a executar as threads em si</li>
							<li>demasiado sincronismo entre threads poderá provocar uma diminuição da performance da aplicação visto que operações de sincronização são demoradas</li>
							<li>a criação de threads poderá diminuir a performance da cache de um processo</li>
						</ul>

						</div>
						
						<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Hello world">
			<h1>Hello world</h1>
			<p>Para iniciarmos o estudo das pthreads, como habitual, iremos contruir um exemplo helloworld. O executável espera um parâmetro na linha de comandos que indica o número de threads a executar e, cada thread irá colocar no stdout uma pequena mensagem com o seu índice na pool das threads.</p>

			<h4 id="hello_oqvu">O que vamos utilizar?</h4>
			<pre><code class="c">pthread_t</code></pre>
			<p>Tipo usado para identificar uma thread - http://pubs.opengroup.org/onlinepubs/7908799/xsh/systypes.h.html</p>
			<pre><code class="c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);</code></pre> 
            <p>Cria uma nova thread que tem como ponto de entrada o método passado no terceiro argumento e, esse método, tem como parâmetro o quarto argumento da função pthread_create(). O primeiro parâmetro deverá ser um pointer para o handle da thread. Retorna 0 caso a thread tenha sido criada com sucesso ou um código de erro caso contrário. http://man7.org/linux/man-pages/man3/pthread_create.3.html</p>
			<pre><code class="c">void pthread_exit(void *retval);</code></pre> 
			<p>Termina a thread corrente e o seu valor de retorno é usado aquando a invocação da função pthread_join().http://man7.org/linux/man-pages/man3/pthread_exit.3.html</p>

			<h4 id="hello_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make hello</kbd>
			<h4 id="hello_programa">helloworld.c</h4>
			<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>



void* hello(void * thread) {
  printf("HELLO WORLD BY THREAD %ld\n",(long)thread);

  pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  int nthreads=0;
  if(argc==2)
    nthreads=atoi(argv[1]);
  else{
    printf(
    "USAGE: helloworld &lt;threads>\n"
    "\n"
    "ARGUMENTS\n"
    "  &lt;threads>  Number of threads to create that increment a value\n"
    "\n"
    "Creates &lt;threads> threads and makes them print their a message with their index in the pool to stdout.\n");
    exit(0);
  } 
  pthread_t threads[nthreads];
  int i=0;

  for(i=0;i< nthreads;++i){

    int res = pthread_create(&threads[i], NULL, hello, (void*)i);
    if(res){
      printf("ERROR:     return code from pthread_create() is %d\n", res);
      exit(-1);
    }    
  }
  
  
/*calling exit(0) will terminate the whole process and, consequently, the threads.
Use pthread_exit to make sure the process only gets terminated upon all threads completion.*/
    pthread_exit(NULL); 
}
			</code></pre>
			<h4 id="hello_output">Output</h4>
			<kbd>HELLO WORLD BY THREAD 0<br>
HELLO WORLD BY THREAD 7<br>
HELLO WORLD BY THREAD 2<br>
HELLO WORLD BY THREAD 3<br>
HELLO WORLD BY THREAD 4<br>
HELLO WORLD BY THREAD 5<br>
HELLO WORLD BY THREAD 6<br>
HELLO WORLD BY THREAD 1<br>
HELLO WORLD BY THREAD 8<br>
HELLO WORLD BY THREAD 9</kbd>
			<h4 id="hello_oqa">O que aconteceu?</h4>
			
			<p>Foram criadas &lt;threads> threads, conforme passado como argumento para a função e cada uma colocou no stdout o seu indice na pool.</p>
			<p>É de notar que, como cada thread tem uma linha de execução independente, poderão não executar pela ordem que foram criadas.</p>
		</div>
















		<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Increment">


			<h1>Increment</h1>
			<p>Queremos agora que as thread efetuem algo mais que colocar strings no stdout. Para o propósito desta página iremos atualizar o código anterior, criando agora uma variável global que será incrementada apenas uma vez pelas várias threads e comentar os resultados obtidos.</p>

			<h4 id="inc_oqvu">O que vamos utilizar?</h4>
			
			<p>Nada de novo, vamos apenas atualizar o código existente.</p>

			<h4 id="inc_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make inc_trap</kbd>
			<h4 id="inc_programa">incremental_trap.c</h4>
			<pre><code class="c">

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>


int i=0;

void* inc(void * threadid) {
		i++;
	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  
	int nthreads=0;
	if(argc==2)
		nthreads=atoi(argv[1]);
	else{
		printf(
		"USAGE: inc_trap &lt;threads>\n"
		"\n"
		"ARGUMENTS\n"
		"  &lt;threads>  Number of threads to create that increment a value\n"
		"\n"
		"Since every thread increment the same variable only once, it's expected that the final result will be == to <threads>\n"
		"Try running '$int_trap 1' to confirm such behaviour\n"
		"Afterwards try running '$int_trap 999'\n");
	}	
	
	pthread_t threads[nthreads];
	

	for(int t=0;t< nthreads;++t){

    	int res = pthread_create(&threads[t], NULL, inc, NULL);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}	

  	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
	pthread_exit(NULL);
}
				</code></pre>
			<h4 id="inc_output">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:(&lt;threads>-1)</kbd>
			<h4 id="inc_oqa">O que aconteceu?</h4>
			
			<p>Enquanto o main está no ciclo for e, como a instrução de incrementar é simples, as threads executam imediatamente e incrementam o valor corretamente porém, main sendo também ela uma thread tem uma linha de execução diferente e coloca no stdout o resultado antes da última thread o incrementar (pode até acontecer a várias threads).</p>
			<p>Uma solução seria apenas fazer printf após o pthread_exit pois este, no main, garante que as threads filhas terminem e funciona como um ponto de execução porém tal é impossível visto que o pthread_exit funciona como um return e termina a thread atual...</p>
			<p>Iremos de seguida ver a solução para este problema</p>

			<h4 id="inc_oqvu2">O que vamos utilizar?</h4>
			<pre><code class="c">int pthread_join(pthread_t thread, void **retval);</code></pre> 
			<p>Esta função aguarda que a thread passada como parâmetro termine antes de prosseguir.Coloca em retval o valor passado na função pthread_exit da thread terminada.http://man7.org/linux/man-pages/man3/pthread_join.3.html</p>
			<h4 id="inc_compilacao2">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make inc</kbd>
			<h4 id="inc_programa2">incremental.c</h4>
			.</br>
			.</br>
			.</br>
			<pre><code class="c">
int main(){

.
.
.
for(int t=0;t< nthreads;++t)
	<b>pthread_join(threads[t], NULL);</b>

	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
	pthread_exit(NULL);
}</code></pre>
<h4 id="inc_output2">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:&lt;threads></kbd>
			<h4 id="inc_oqa2">O que aconteceu?</h4>
			<p>Ao invocarmos pthread_join sobre todas as threads da pool garantimos que estas terminam antes da função main continuar a sua execução imprimindo assim o valor correcto da variável result.</p>
			<p>Porém, se executarmos o programa vezes suficientes e com threads suficientes podemos ter um output inesperado...</p>

			 <kbd>$./inc 999<br>
Number of threads:999   incremental result:999<br>
$./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;./inc 999;<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:998        &lt;-----------<br>
Number of threads:999   incremental result:999<br>
Number of threads:999   incremental result:999</kbd>
			s
</div>




<div class="container-fluid" style="padding-top:70px;padding-bottom:70px" id="Mutexes">
	<h1>Mutexes</h1>
	<p>Para resolver problemas de concorrência a API pthreads proporciona-nos mutexes que fornecem acesso atómico às pthreads, ou seja, garantem que, o acesso a recursos partilhados sejam efetuados exclusivamente pela thread que detêm o acesso aos mesmos.</p>
			<h4 id="mut_oqvu3">O que vamos utilizar?</h4>
			<pre><code class="c">pthread_mutex_t</code></pre> 
			<p>Tipo usado para identificar um mutex. http://pubs.opengroup.org/onlinepubs/7908799/xsh/systypes.h.html</p>
			<pre><code class="c">int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></pre> 
			<p>Estas funções criam/destroem um mutex.</p>
			<pre><code class="c">int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></pre> 
			<p>Estas função permitem que uma thread obtenha/disponibilize acesso a um mutex,respectivamente.No caso de unlock o desbloqueio é imediato porém, após invocar o lock, a thread invocadora aguarda até que o acesso esteja disponível e só ent
			ao prossegue com as restantes instruções.      http://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html</p>




			<h4 id="mut_compilacao">Compilação</h4>
			<p>Através do makefile disponibilizado basta executar o seguinte comando na consola (na mesma directoria que o makefile):</p>
			<kbd>$make mutexes</kbd>
			<h4 id="mut_programa">mutexes.c</h4>
			<pre><code class="c">
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pthread.h>


int i=0;
pthread_mutex_t i_mutex;

void* inc(void * threadid) {

	pthread_mutex_lock(&i_mutex);
	i++;
	pthread_mutex_unlock(&i_mutex);

	pthread_exit(NULL);
}

int main(int argc,  char** argv) {
  
	int nthreads=0;
	if(argc==2)
		nthreads=atoi(argv[1]);
	else{
		printf(
		"USAGE: mutexes &lt;threads>\n"
		"\n"
		"ARGUMENTS\n"
		"  &lt;threads>  Number of threads to create that increment a value\n"
		"\n"
		"Since every thread increment the same variable only once, it's expected that the final result will be == to <threads>\n"
		"Try running '$int_trap 10' to confirm such behaviour\n"
		"Afterwards try running '$int_trap 999' several times and see what happens\n"
		"To ease the repetion of commands try the following:\n"
		"'$int_trap 999'\n"
		"'$!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;!!;'\n");
	}	
	
	pthread_t threads[nthreads];
	
	pthread_mutex_init(&i_mutex,NULL);

	for(int t=0;t< nthreads;++t){

    	int res = pthread_create(&threads[t], NULL, inc, NULL);
    	if(res){
	      printf("ERROR:     return code from pthread_create() is %d\n", res);
	      exit(-1);
	    }    
	}	
	
	for(int t=0;t< nthreads;++t)
  		pthread_join(threads[t], NULL);
  	printf("Number of threads:%d   incremental result:%d\n",nthreads,i);
  	pthread_mutex_destroy(&i_mutex);
	pthread_exit(NULL);
}
</code></pre> 

<h4 id="mut_output">Output</h4>
			<kbd>Number of threads:&lt;threads>   incremental result:&lt;threads></kbd>
			<h4 id="inc_oqa2">O que aconteceu?</h4>
			<p>Após incluirmos mutexes no código da aplicação. cada bloco lock-unlock apenas executa na sua totalidade pela thread detentora do lock, eliminando assim acessos concorrentes à variável incrementada.</p>

			<p>Eis um diagrama a ilustrar a situação:</p>
			<img src="diagrama2.png">
		</div>



					</div>




				</div>
			
			

&lt;



FALTA FALAR DE:
-		deadlock
-		nodeadlock
-		conditionals
-		parametros
-		thread_cancel
-		thread_detach
-		tipos de atributos para os mutexes



pthread_exit

-When a thread terminates, process-shared resources (e.g., mutexes,
       condition variables, semaphores, and file descriptors) are not
       released, and functions registered using atexit(3) are not called.




INFO ADICIONAL:
	This independent flow of control is accomplished because a thread maintains its own:
Stack pointer
Registers
Scheduling properties (such as policy or priority)
Set of pending and blocked signals
Thread specific data.

















leitura adicional:
http://www.drdobbs.com/parallel/the-pillars-of-concurrency/200001985



		<br>
		<footer>
			<div class="row justify-content-around">     
				<p>a62362 - aXXXXX - aXXXXX - aXXXXX - aXXXXX</p>
			</div>
		</footer>
</div>
  
	</body>
</html>
